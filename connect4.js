/** Connect Four
 *
 * Player 1 and 2 alternate turns. On each turn, a piece is dropped down a
 * column until a player gets four-in-a-row (horiz, vert, or diag) or until
 * board fills (tie)
 */

let WIDTH = 7;
let HEIGHT = 6;

let currPlayer = 1; // active player: 1 or 2
let board = []; // array of rows, each row is array of cells  (board[y][x])

/** makeBoard: create in-JS board structure:
 *    board = array of rows, each row is array of cells  (board[y][x])
 */

function makeBoard() {
  // TODO: set "board" to empty HEIGHT x WIDTH matrix array
  // Used solution code
  for (let y = 0; y < HEIGHT; y++) {
    // Do not understand what we are doing here.
    board.push(Array.from({ length: WIDTH }));
  }
  // My code
  // board.WIDTH = 0;
  // board.HEIGHT = 0;
}

/** makeHtmlBoard: make HTML table and row of column tops. */

function makeHtmlBoard() {
  // TODO: get "htmlBoard" variable from the item in HTML w/ID of "board"
  // My code did not work
  // let htmlBoard = document.querySelector('#board');

  // Solution code
  const board = document.getElementById('board');

  // TODO: add comment for this code
  // Making the top row for the player to be able to select row for adding connect four
  const top = document.createElement('tr');
  // Setting attribute of id on the top tr where the user interacts to drop in a piece.
  top.setAttribute('id', 'column-top');
  // adding an event listener for a click event on the top tr of the board.
  top.addEventListener('click', handleClick);

  for (let x = 0; x < WIDTH; x++) {
    const headCell = document.createElement('td');
    headCell.setAttribute('id', x);
    top.append(headCell);
  }
  board.append(top);

  // TODO: add comment for this code
  // Using nested loops, this loop creates the tr rows for the board but not to exceed the set HEIGHT of 6. Each iteration thorough the loop creates a tr DOM element.
  for (let y = 0; y < HEIGHT; y++) {
    const row = document.createElement('tr');
    // Using this loop to create the width of the board by creating td boxes for the player tokens to be placed but size not to exceed the set WIDTH of 7. Each iteration thorough the loop creates a td DOM element.
    for (let x = 0; x < WIDTH; x++) {
      const cell = document.createElement('td');
      // Now we set the id of each cell to the y coordinate and the x coordinate in a format with the - in between y and x. The number is generated by the above loops and added as an attribute with a id.
      cell.setAttribute('id', `${y}-${x}`);
      // Now we append the tr's "variable rows" to the td's "varaiable cells".
      row.append(cell);
    }
    board.append(row);
  }
}

/** findSpotForCol: given column x, return top empty y (null if filled) */

function findSpotForCol(x) {
  // TODO: write the real version of this, rather than always returning 0
  // Solution code
  for (let y = HEIGHT - 1; y >= 0; y--) {
    if (!board[y][x]) {
      return y;
    }
  }
  return null;
}

/** placeInTable: update DOM to place piece into HTML table of board */

function placeInTable(y, x) {
  // TODO: make a div and insert into correct table cell
  // I added this code below on my own
  // const newDiv = document.createElement('div');
  // My code
  // newDiv.className = 'piece';
  // newDiv.className = currPlayer;
  // newDiv.append('td', `${y} - ${x}`);
  // newDiv.classList.add('piece');
  // newDiv.classList.add(`p${currPlayer}`);
  // const newSpot = document.getElementById(`${y} - ${x}`);
  // Line 86 is solution code -- edited name to match my piece name
  // newDiv.style.top = -50 * (y + 2);
  // newSpot.append(newDiv);

  // Solution code
  const piece = document.createElement('div');
  piece.classList.add('piece');
  piece.classList.add(`p${currPlayer}`);
  piece.style.top = -50 * (y + 2);

  const spot = document.getElementById(`${y}-${x}`);
  spot.append(piece);
}

/** endGame: announce game end */

function endGame(msg) {
  // TODO: pop up alert message
  // Figured this out without solution code, double checked with solution code.
  alert(msg);
}

/** handleClick: handle click of column top to play piece */

function handleClick(evt) {
  // get x from ID of clicked cell
  var x = +evt.target.id;

  // get next spot in column (if none, ignore click)
  var y = findSpotForCol(x);
  if (y === null) {
    return;
  }

  // place piece in board and add to HTML table
  // TODO: add line to update in-memory board
  // Solution code
  board[y][x] = currPlayer;
  placeInTable(y, x);

  // check for win
  // Solution code
  if (checkForWin()) {
    return endGame(`Player ${currPlayer} won!`);
  }

  // check for tie
  // TODO: check if all cells in board are filled; if so call, call endGame
  // Solution code
  if (board.every((row) => row.every((cell) => cell))) {
    return endGame('Tie!');
  }
  // switch players
  // TODO: switch currPlayer 1 <-> 2
  // Solution code
  currPlayer = currPlayer === 1 ? 2 : 1;
}

/** checkForWin: check board cell-by-cell for "does a win start here?" */

function checkForWin() {
  function _win(cells) {
    // Check four cells to see if they're all color of current player
    //  - cells: list of four (y, x) cells
    //  - returns true if all are legal coordinates & all match currPlayer

    return cells.every(
      ([y, x]) =>
        y >= 0 &&
        y < HEIGHT &&
        x >= 0 &&
        x < WIDTH &&
        board[y][x] === currPlayer
    );
  }

  // TODO: read and understand this code. Add comments to help you.
  // Need to go over with mentor -- do not understand
  for (var y = 0; y < HEIGHT; y++) {
    for (var x = 0; x < WIDTH; x++) {
      var horiz = [
        [y, x],
        [y, x + 1],
        [y, x + 2],
        [y, x + 3],
      ];
      var vert = [
        [y, x],
        [y + 1, x],
        [y + 2, x],
        [y + 3, x],
      ];
      var diagDR = [
        [y, x],
        [y + 1, x + 1],
        [y + 2, x + 2],
        [y + 3, x + 3],
      ];
      var diagDL = [
        [y, x],
        [y + 1, x - 1],
        [y + 2, x - 2],
        [y + 3, x - 3],
      ];

      if (_win(horiz) || _win(vert) || _win(diagDR) || _win(diagDL)) {
        return true;
      }
    }
  }
}

makeBoard();
makeHtmlBoard();
